<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[RecyclerView的简单用法]]></title>
    <url>%2F2017%2F08%2F23%2FAndroid%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2FRecyclerView%E7%9A%84%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前面的话本文使用的 IDE 是 Android Studio 2.3.1 ，模拟器是夜神模拟器 5.0.0.0 。文章为学习《第一行代码——Android》（第二版）时所记录的内容，可能包含遇到的问题，仅供学习交流。 准备工作首先，在Android Studio上新建一个项目，项目名叫RecyclerViewTest，并让Android Studio自动帮我们创建好活动。 RecyclerView的基本用法添加依赖库RecyclerView属于新增的控件，所以首先需要在项目的build.gradle中添加相应的依赖库。打开app/build.gradle文件，在dependencies闭包中添加如下内容：12345678910dependencies &#123; compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;]) androidTestCompile(&apos;com.android.support.test.espresso:espresso-core:2.2.2&apos;, &#123; exclude group: &apos;com.android.support&apos;, module: &apos;support-annotations&apos; &#125;) compile &apos;com.android.support:appcompat-v7:25.3.1&apos; compile &apos;com.android.support:recyclerview-v7:25.3.1&apos; compile &apos;com.android.support.constraint:constraint-layout:1.0.2&apos; testCompile &apos;junit:junit:4.12&apos;&#125; 添加的代码如下（后面的数字与上面的一项相同即可）：1compile &apos;com.android.support:recyclerview-v7:25.3.1&apos; 添加完成之后，记得要点击一下右上角的Sync Now来进行同步。 修改布局和活动文件修改activity_main.xml中的代码，如下所示：123456789&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;android.support.v7.widget.RecyclerView android:id="@+id/recycler_view" android:layout_width="match_parent" android:layout_height="match_parent"&gt;&lt;/android.support.v7.widget.RecyclerView&gt;&lt;/LinearLayout&gt; 需要注意的是，由于RecyclerView并不是内置在系统SDK当中的，所以需要把完整的包路径写出来。因为我们想要使用RecyclerView来实现和上一节中的ListView相同的效果，因此就需要准备一份同样的水果图片。这里我们直接从上一个项目中复制drawable-hdpi到本项目中即可，另外把Fruit类和fruit_item.xml也复制过来，省得将同样的代码再写一遍。其中，Fruit类用于存储水果数据，内容如下所示：123456789101112131415161718public class Fruit &#123; private String name; private int imageId; public Fruit(String name, int imageId) &#123; this.name = name; this.imageId = imageId; &#125; public String getName() &#123; return name; &#125; public int getImageId() &#123; return imageId; &#125;&#125; fruit_item.xml用于子项自定义布局，内容如下所示：123456789101112131415161718&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;ImageView android:id="@+id/fruit_image" android:layout_width="wrap_content" android:layout_height="wrap_content"/&gt; &lt;TextView android:id="@+id/fruit_name" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_vertical" android:layout_marginLeft="10dp"/&gt;&lt;/LinearLayout&gt; 紧接着我们需要为RecyclerView准备一个适配器，新建FruitAdapter类，代码如下所示：12345678910111213141516171819202122232425262728293031323334353637public class FruitAdapter extends RecyclerView.Adapter&lt;FruitAdapter.ViewHolder&gt; &#123; private List&lt;Fruit&gt; mFruitList; public FruitAdapter(List&lt;Fruit&gt; fruitList) &#123; mFruitList = fruitList; &#125; @Override public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.fruit_item, parent, false); ViewHolder holder = new ViewHolder(view); return holder; &#125; @Override public void onBindViewHolder(ViewHolder holder, int position) &#123; Fruit fruit = mFruitList.get(position); holder.fruitImage.setImageResource(fruit.getImageId()); holder.fruitName.setText(fruit.getName()); &#125; @Override public int getItemCount() &#123; return mFruitList.size(); &#125; static class ViewHolder extends RecyclerView.ViewHolder &#123; ImageView fruitImage; TextView fruitName; public ViewHolder(View itemView) &#123; super(itemView); fruitImage = (ImageView) itemView.findViewById(R.id.fruit_image); fruitName = (TextView) itemView.findViewById(R.id.fruit_name); &#125; &#125;&#125; 这里首先定义了一个内部类ViewHolder，ViewHolder要继承自RecyclerView.ViewHolder。然后ViewHolder的构造方法中要传入一个View参数，这个参数通常就是RecyclerView子项的最外层布局，那么我们就可以通过findViewById()方法来获取到布局中的ImageView和TextView的实例了。接下来，FruitAdapter中也有一个构造方法，这个方法用于把要展示的数据源传进来，并赋值给一个全局变量mFruitList，我们后续的操作都将在这个数据源的基础上进行。由于FruitAdapter是继承自RecyclerView.Adapter的，那么就必须重写onCreateViewHolder()、onBindViewHolder()和getItemCount()这3个方法。onCreateViewHolder()方法是用于创建ViewHolder实例的，在这个方法中将fruit_item布局加载进来，然后创建一个ViewHolder实例，并把加载出来的布局传入到构造方法中，最后将ViewHolder的实例返回。onBindViewHolder()方法是用于对RecyclerView子项的数据进行赋值的，会在每个子项被滚动到屏幕内的时候执行，这里我们通过position参数得到当前项的Fruit实例，然后再将数据设置到ViewHolder的ImageView和TextView当中即可。getItemCount()方法就非常简单了，它用于告诉RecyclerView一共有多少子项，直接返回数据源的长度就可以了。适配器准备好了之后，我们就可以开始使用RecyclerView了，修改MainActivity中的代码，如下所示：12345678910111213141516171819202122232425262728293031323334353637383940public class MainActivity extends AppCompatActivity &#123; private List&lt;Fruit&gt; fruitList = new ArrayList&lt;&gt;(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initFruits(); // 初始化水果数据 RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recycler_view); LinearLayoutManager layoutManager = new LinearLayoutManager(this); recyclerView.setLayoutManager(layoutManager); FruitAdapter adapter = new FruitAdapter(fruitList); recyclerView.setAdapter(adapter); &#125; private void initFruits() &#123; for (int i=0; i&lt;2; ++i) &#123; Fruit apple = new Fruit("Apple", R.drawable.apple_pic); fruitList.add(apple); Fruit banana = new Fruit("Banana", R.drawable.banana_pic); fruitList.add(banana); Fruit orange = new Fruit("Orange", R.drawable.orange_pic); fruitList.add(orange); Fruit watermelon = new Fruit("Watermelon", R.drawable.watermelon_pic); fruitList.add(watermelon); Fruit pear = new Fruit("Pear", R.drawable.pear_pic); fruitList.add(pear); Fruit grape = new Fruit("Grape", R.drawable.grape_pic); fruitList.add(grape); Fruit pineapple = new Fruit("Pineapple", R.drawable.pineapple_pic); fruitList.add(pineapple); Fruit strawberry = new Fruit("Strawberry", R.drawable.strawberry_pic); fruitList.add(strawberry); Fruit cherry = new Fruit("Cherry", R.drawable.cherry_pic); fruitList.add(cherry); Fruit mango = new Fruit("Mango", R.drawable.mango_pic); fruitList.add(mango); &#125; &#125;&#125; 这里，首先使用了一个和ListViewTest项目同样的initFruits()方法，用于初始化所有的水果数据。接着在onCreate()方法中先获取到RecyclerView的实例，然后创建一个LinearLayoutManager对象，并将它设置到RecyclerView当中。LayoutManager用于指定RecyclerView的布局方式，这里使用的LinearLayoutManager是线性布局的意思，可以实现和ListView类似的效果。接下来我们创建了FruitAdapter的实例，并将水果数据传入到FruitAdapter的构造方法中，最后调用RecyclerView的setAdapter()方法来完成适配器设置，这样RecyclerView和数据之间的关联就建立完成了。运行程序，效果如下所示：可以看到，我们使用RecyclerView实现了和ListView几乎一模一样的效果，虽说代码量并没有明显地减少，但是逻辑变得更加清晰了。当然这只是RecyclerView的基本用法而已，接下来我们就要看看RecyclerView还能实现哪些ListView实现不了的效果。 实现横向滚动我们知道，ListView的扩展性并不好，它只能实现纵向滚动的效果，如果想进行横向滚动的话，ListView就做不到了。这样的话，我们就需要借助于RecyclerView了。首先要对fruit_item布局进行修改，因为目前这个布局里面的元素是水平排列的，适用于纵向滚动的场景，而如果我们要实现横向滚动的话，应该把fruit_item里的元素改成垂直排列才比较合理。修改fruit_item.xml中的代码，如下所示：1234567891011121314151617181920&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="100dp" android:layout_height="wrap_content"&gt; &lt;ImageView android:id="@+id/fruit_image" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_horizontal"/&gt; &lt;TextView android:id="@+id/fruit_name" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_horizontal" android:layout_marginTop="10dp"/&gt;&lt;/LinearLayout&gt; 这里，我们将LinearLayout改成垂直方向排列，并把宽度设为100dp。这里将宽度指定为固定值是因为每种水果的文字长度不一致，如果用wrap_content的话，RecyclerView的子项就会有长有短，非常不美观；而如果用match_parent的话，就会导致宽度过长，一个子项占满整个屏幕。最后，我们将ImageView和TextView都设置成了在布局中水平居中，并且使用layout_marginTop属性让文字和图片之间保持一些距离。接下来，在MainActivity中添加代码如下：123LinearLayoutManager layoutManager = new LinearLayoutManager(this);layoutManager.setOrientation(LinearLayoutManager.HORIZONTAL); // 添加的内容recyclerView.setLayoutManager(layoutManager); 注意：MainActivity中只加入了一行代码，调用LinearLayoutManager的setOrientation()方法来设置布局的排列方向，默认是纵向排列的，我们传入LinearLayoutManager.HORIZONTAL表示让布局横行排列，这样RecyclerView就可以横向滚动了。 运行程序，效果如下所示：为什么ListView很难或者根本无法实现的效果在RecyclerView上这么轻松就能实现了呢？这主要得益于RecyclerView出色的设计。ListView的布局排列是由自身去管理的，而RecyclerView则将这个工作交给了LayoutManager，LayoutManager中制定了一套可扩展的布局排列接口，子类只要按照接口的规范来实现，就能定制出各种不同排列方式的布局了。 实现瀑布流布局首先还是来修改一下fruit_item.xml中的代码，如下所示：123456789101112131415161718192021&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_margin="5dp"&gt; &lt;ImageView android:id="@+id/fruit_image" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_horizontal"/&gt; &lt;TextView android:id="@+id/fruit_name" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="left" android:layout_marginTop="10dp"/&gt;&lt;/LinearLayout&gt; 首先将LinearLayout的宽度由100dp改成了match_parent，因为瀑布流布局的宽度应该是根据布局的列数来自动适配的，而不是一个固定值。另外我们使用了layout_margin属性来让子项之间互留一点间距，这样就不至于所有子项都紧贴在一起。还有就是将TextView的对齐属性改成了居左对齐，因为待会儿我们会将文字的长度变长，如果还是居中显示，会感觉怪怪的。修改MainActivity中的代码，如下所示：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class MainActivity extends AppCompatActivity &#123; private List&lt;Fruit&gt; fruitList = new ArrayList&lt;&gt;(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initFruits(); // 初始化水果数据 RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recycler_view); StaggeredGridLayoutManager layoutManager = new StaggeredGridLayoutManager(3, StaggeredGridLayoutManager.VERTICAL); recyclerView.setLayoutManager(layoutManager); FruitAdapter adapter = new FruitAdapter(fruitList); recyclerView.setAdapter(adapter); &#125; private void initFruits() &#123; for (int i=0; i&lt;2; ++i) &#123; Fruit apple = new Fruit(getRandomLengthName("Apple"), R.drawable.apple_pic); fruitList.add(apple); Fruit banana = new Fruit(getRandomLengthName("Banana"), R.drawable.banana_pic); fruitList.add(banana); Fruit orange = new Fruit(getRandomLengthName("Orange"), R.drawable.orange_pic); fruitList.add(orange); Fruit watermelon = new Fruit(getRandomLengthName("Watermelon"), R.drawable.watermelon_pic); fruitList.add(watermelon); Fruit pear = new Fruit(getRandomLengthName("Pear"), R.drawable.pear_pic); fruitList.add(pear); Fruit grape = new Fruit(getRandomLengthName("Grape"), R.drawable.grape_pic); fruitList.add(grape); Fruit pineapple = new Fruit(getRandomLengthName("Pineapple"), R.drawable.pineapple_pic); fruitList.add(pineapple); Fruit strawberry = new Fruit(getRandomLengthName("Strawberry"), R.drawable.strawberry_pic); fruitList.add(strawberry); Fruit cherry = new Fruit(getRandomLengthName("Cherry"), R.drawable.cherry_pic); fruitList.add(cherry); Fruit mango = new Fruit(getRandomLengthName("Mango"), R.drawable.mango_pic); fruitList.add(mango); &#125; &#125; private String getRandomLengthName(String name) &#123; Random random = new Random(); int length = random.nextInt(20)+1; StringBuilder builder = new StringBuilder(); for (int i = 0; i &lt; length; ++i) &#123; builder.append(name); &#125; return builder.toString(); &#125;&#125; 首先，在onCreate()方法中，我们创建了一个StaggeredGridLayoutManager的实例。StaggeredGridLayoutManager的构造方法接收两个参数，第一个参数用于指定布局的列数，传入 3 表示会把布局分为 3 列；第二个参数用于指定布局的排列方向，传入StaggeredGridLayoutManager.VERTICAL表示会让布局纵向排列，最后再把创建好的实例设置到RecyclerView当中就可以了。没错，仅仅修改了一行代码，我们就已经成功实现瀑布流布局的效果了。不过由于瀑布流布局需要各个子项的高度不一致时才能看出明显的效果，因此设计了一个getRandomLengthName()方法，这个方法使用了Random对象来创造一个 1 到 20 之间的随机数，然后将参数中传入的字符串重复随机遍。在initFruits()方法中，每个水果的名字都改成调用getRandomLengthName()这个方法来生成，这样就能保证各水果名字的长短差距都比较大，子项的高度也就各不相同了。运行程序，效果如下所示： RecyclerView的点击事件不同于ListView的是，RecyclerView并没有提供类似于setOnItemClickListener()这样的注册监听器方法，而是需要我们自己给子项具体的View去注册点击事件，相比于ListView来说，实现起来要复杂一些。那么你可能就有疑问了，为什么RecyclerView在各个方面的设计都要优于ListView，偏偏在点击事件上却没有处理得非常好呢？其实不是这样的，ListView在点击事件上的处理并不人性化，setOnItemClickListener()方法注册的是子项的点击事件，但如果我想点击的是子项里面具体的某一个按钮呢？虽然ListView也是能做到的，但是实现起来就相对比较麻烦了。为此，RecyclerView干脆直接摒弃了子项点击事件的监听器，所有的点击事件都由具体的View去注册，就再没有这个困扰了。下面注册点击事件，修改FruitAdapter中的代码，如下所示：1234567891011121314151617181920212223242526272829303132333435363738394041public class FruitAdapter extends RecyclerView.Adapter&lt;FruitAdapter.ViewHolder&gt; &#123; ...... @Override public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.fruit_item, parent, false); final ViewHolder holder = new ViewHolder(view); holder.fruitView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; int position = holder.getAdapterPosition(); Fruit fruit = mFruitList.get(position); Toast.makeText(v.getContext(), "you clicked view " + fruit.getName(), Toast.LENGTH_SHORT).show(); &#125; &#125;); holder.fruitImage.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; int position = holder.getAdapterPosition(); Fruit fruit = mFruitList.get(position); Toast.makeText(v.getContext(), "you clicked image " + fruit.getName(), Toast.LENGTH_SHORT).show(); &#125; &#125;); return holder; &#125; ...... static class ViewHolder extends RecyclerView.ViewHolder &#123; View fruitView; ImageView fruitImage; TextView fruitName; public ViewHolder(View itemView) &#123; super(itemView); fruitView = itemView; fruitImage = (ImageView) itemView.findViewById(R.id.fruit_image); fruitName = (TextView) itemView.findViewById(R.id.fruit_name); &#125; &#125;&#125; 首先修改了ViewHolder，在ViewHolder中添加了fruitView变量来保存子项最外层布局的实例，然后在onCreateViewHolder()方法中注册点击事件就可以了。这里分别为最外层布局和ImageView都注册了点击事件，RecyclerView的强大之处也在这里，它可以轻松地实现子项中任意控件或布局的点击事件。我们在两个点击事件中先获取了用户点击的position，然后通过position拿到相应的Fruit实例，再使用Toast分别弹出两种不同的内容以示区别。运行程序，点击梨子的图片部分，效果如下所示：然后再点击草莓的文字部分，效果如下所示： 注意：由于TextView并没有注册点击事件，因此点击文字这个事件会被子项的最外层布局捕获到。 注意： 文中所提到的图片可以从作者的源码库中获取，点击这里。]]></content>
      <categories>
        <category>Android学习笔记</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>RecyclerView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F08%2F19%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>test</tag>
      </tags>
  </entry>
</search>
