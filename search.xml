<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2017年下学期程序设计实践-模拟测试3]]></title>
    <url>%2F2017%2F12%2F24%2FXTU%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E8%B7%B5%2F2017%E5%B9%B4%E4%B8%8B%E5%AD%A6%E6%9C%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E8%B7%B5-%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%953%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[2017年下学期程序设计实践-模拟测试2]]></title>
    <url>%2F2017%2F12%2F24%2FXTU%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E8%B7%B5%2F2017%E5%B9%B4%E4%B8%8B%E5%AD%A6%E6%9C%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E8%B7%B5-%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%952%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[2017年下学期《C语言程序设计》课堂测验-2题解]]></title>
    <url>%2F2017%2F12%2F24%2FXTU%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E8%B7%B5%2F2017%E5%B9%B4%E4%B8%8B%E5%AD%A6%E6%9C%9F%E3%80%8AC%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E8%AF%BE%E5%A0%82%E6%B5%8B%E9%AA%8C-2%2F</url>
    <content type="text"><![CDATA[前面的话本文使用的编辑器是 Sublime Text 3，Build 3143，编译器是 GCC 5.2.1。文章为湘潭大学程序设计实践网站一些考试编程题目的个人题解，不保证是最优解法，仅供参考学习。 巧了，当时又闲得无聊，恰好又碰上了这个测验，索性就做了做，网址如下所示：2017年下学期《C语言程序设计》课堂测验-2。如果不能看到题目，可以直接搜索题号1290~1297。 Problem A很简单的签到题，判断一下是哪个类型就可以了。代码如下所示： 123456789101112131415161718192021222324#include &lt;cstdio&gt;const int maxn = 10;char s[maxn], t[maxn];int main() &#123; int T; scanf("%d", &amp;T); while (T--) &#123; scanf("%s%s", s, t); if (s[0] == t[0]) puts("Draw"); else &#123; bool ok = false; if (s[0] == 'r') ok = t[0]=='s'; else if (s[0] == 'p') ok = t[0]=='r'; else ok = t[0]=='p'; puts(ok ? "Alice" : "Bob"); &#125; &#125; return 0;&#125; Problem B要比较最好的与最差的差异，显然需要排序一下。排序完成之后，连续m个一直找，并且与答案相互比较，更优就替换即可，先预处理一下前缀和，这样可以快速求得解，思路比较简单。代码如下所示： 12345678910111213141516171819202122232425262728#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 1005;int num[maxn], sum[maxn];int n, m;int main() &#123; int T; scanf("%d", &amp;T); while (T--) &#123; scanf("%d%d", &amp;n, &amp;m); for (int i=0; i&lt;n; ++i) scanf("%d", num+i); sort(num, num+n); sum[0] = num[0]; for (int i=1; i&lt;n; ++i) sum[i] = sum[i-1]+num[i]; int ans=num[m-1]-num[0], res=sum[m-1]; for (int i=m; i&lt;n; ++i) if (num[i]-num[i-m+1] &lt; ans) &#123; ans = num[i]-num[i-m+1]; res = sum[i]-sum[i-m]; &#125; printf("%d %d\n", ans, res); &#125; return 0;&#125; Problem C串长度不长，根据题意，枚举一下各个长度，然后选择这么长的一个子串，并且判定一下是否满足题意，满足就记录下来，最后取最长的就可以了。那么既然是这样，我从长度大的开始枚举，如果符合就一定是答案，直接退出就好了，如果最后还是没有找到，就输出0。代码如下所示： 1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;#include &lt;cstring&gt;const int maxn = 1005;char str[maxn];bool check(int id, int len) &#123; for (int i=0; i&lt;len; ++i) if (str[id+i] != str[id+i+len]) return false; return true;&#125;int main() &#123; int T; scanf("%d", &amp;T); while (T--) &#123; scanf("%s", str); int len=strlen(str), ans=0; bool ok = true; for (int i=len&gt;&gt;1; i&gt;0&amp;&amp;ok; --i) for (int j=0; (j+(i&lt;&lt;1)-1)&lt;len&amp;&amp;ok; ++j) if (check(j, i)) &#123; ans = i&lt;&lt;1; ok = false; &#125; printf("%d\n", ans); &#125; return 0;&#125; Problem D图形输出题，必考题。一般地，都是分为两部分，上面和下面分开处理，会比较容易，仔细找找规律就很容易发现窍门。首先根据行数确定出有几个空格，然后根据行数确定出要输出几个字母就行了。代码如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;int n;void solve() &#123; int cnt = n-1; for (int i=0; i&lt;n; ++i) &#123; for (int j=0; j&lt;cnt; ++j) putchar(' '); char ch = 'A'+n; for (int j=0; j&lt;=i; ++j) putchar(--ch); char t = 'A'+n-1; for (; ch&lt;t;) putchar(++ch); puts(""); --cnt; &#125; cnt = 1; for (int i=1; i&lt;n; ++i) &#123; for (int j=0; j&lt;cnt; ++j) putchar(' '); char ch = 'A'+n; for (int j=n-i-1; j&gt;=0; --j) putchar(--ch); char t = 'A'+n-1; for (; ch&lt;t;) putchar(++ch); puts(""); ++cnt; &#125;&#125;int main() &#123; int T; scanf("%d", &amp;T); while (T--) &#123; scanf("%d", &amp;n); solve(); &#125; return 0;&#125; Problem E根据题意，只需要相邻两个判断一下，不相同则表示男女相邻，计数加一即可。但是涉及到询问，所以就预处理某个人前面总共满足要求的数目，最后询问区间直接相减就可得答案。代码如下所示： 123456789101112131415161718192021#include &lt;cstdio&gt;const int maxn = 10005;char str[maxn];int sum[maxn];int n;int main() &#123; int T; scanf("%d", &amp;T); while (T--) &#123; scanf("%s%d", str+1, &amp;n); for (int i=2; str[i]; ++i) sum[i] = sum[i-1]+(str[i]!=str[i-1]); int x, y; for (int i=0; i&lt;n; ++i) &#123; scanf("%d%d", &amp;x, &amp;y); printf("%d\n", sum[y]-sum[x]); &#125; &#125; return 0;&#125; Problem F根据题意，数据不是非常大，依次从低位向高位取，如果遇到高位为0，直接返回不满足，或者发现其不是素数也返回不满足，最终都满足那么就返回满足。进而题目就只需要会素数判断就好了。代码如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cmath&gt;int n;bool is_prime(int x) &#123; if (x==0 || x==1) return false; if (x==2 || x==3) return true; if (x%2 == 0) return false; int t = (int)sqrt(x+0.5); for (int i=3; i&lt;=t; ++i) if (x%i == 0) return false; return true;&#125;bool check(int x) &#123; int ans=0, y=1; while (x) &#123; int t = x%10; if (t == 0) return false; ans += t*y; if (!is_prime(ans)) return false; x /= 10; y *= 10; &#125; return true;&#125;int main() &#123; int T; scanf("%d", &amp;T); while (T--) &#123; scanf("%d", &amp;n); puts(check(n) ? "Yes" : "No"); &#125; return 0;&#125; Problem G根据题意，问[a, b]区间内与6互素的数的个数，而6=2*3，所以问题可以转换为求[a, b]区间内能被2或者3整数的数的个数，然后再用总数减去它就是答案了，显然，这就是简单的容斥原理了。代码如下所示： 1234567891011121314151617#include &lt;cstdio&gt;int a, b;int cal(int x) &#123; int t=x/2, d=x/3, y=x/6; return x-t-d+y;&#125;int main() &#123; int T; scanf("%d", &amp;T); while (T--) &#123; scanf("%d%d", &amp;a, &amp;b); printf("%d\n", cal(b)-cal(a-1)); &#125; return 0;&#125; Problem H题目也不难，主要就是对每个人的数据进行统计，最后再按要求输出，这两点不太容易实现。我这里用了map，巧妙地实现了第一点。最后根据相应排名得出相应积分，算出所有人的总积分，取出最大的，然后利用公式对每一个人的成绩进行计算，最后按照分数大的优先输出，相同分数学号小的优先输出即可（我利用了C++的重载运算符进行排序）。代码如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;cstdio&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 500;const int maxm = 15;struct node &#123; string id; int sc; bool operator &lt; (const node &amp; p) const &#123; if (sc == p.sc) return id &lt; p.id; return sc &gt; p.sc; &#125;&#125; p[maxn];char str[maxm], op[maxm];map&lt;string, int&gt; cnt;map&lt;string, int&gt;::iterator it;int check(int x) &#123; if (x &lt; 13) return 32; if (x &lt; 25) return 16; if (x &lt; 49) return 8; if (x &lt; 97) return 4; if (x &lt; 193) return 2; return 1;&#125;int cal(int x, int y) &#123; double t = (double)(x-y)/y; return (int)(100+log(1+t)*10+0.5);&#125;int main() &#123; int r; while (~scanf("%s%s%d", op, str, &amp;r)) cnt[str] += check(r); r = -1; for (it=cnt.begin(); it!=cnt.end(); ++it) if ((it-&gt;second) &gt; r) r = it-&gt;second; int ct = 0; for (it=cnt.begin(); it!=cnt.end(); ++it) &#123; p[ct].id = it-&gt;first; p[ct++].sc = cal(it-&gt;second, r); &#125; sort(p, p+ct); for (int i=0; i&lt;ct; ++i) printf("%s %d\n", p[i].id.c_str(), p[i].sc); return 0;&#125; 总结：总体来说，大部分题目还是比较简单的，平时有练习，及格完全没有任何问题，但是对于大一新生来说，想要AK还是需要花更多时间来思考题目和解题方法的。]]></content>
      <categories>
        <category>XTU程序设计实践</category>
      </categories>
      <tags>
        <tag>XTU</tag>
        <tag>C语言程序设计</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017年下学期程序设计实践-模拟测试1]]></title>
    <url>%2F2017%2F12%2F24%2FXTU%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E8%B7%B5%2F2017%E5%B9%B4%E4%B8%8B%E5%AD%A6%E6%9C%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E8%B7%B5-%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%951%2F</url>
    <content type="text"><![CDATA[前面的话本文使用的编辑器是 Sublime Text 3，Build 3143，编译器是 GCC 5.2.1。文章为湘潭大学程序设计实践网站一些考试编程题目的个人题解，不保证是最优解法，仅供参考学习。 好久没敲算法代码了，就拿来练练手。网址如下所示：2017年下学期程序设计实践-模拟测试1。如果不能看到题目，可以直接搜索题号1284~1289。 Problem A签到题，直接按照题意暴力计算即可（当然，也可以类似十进制各位加权一样计算）。代码如下所示： 123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;const int maxn = 15;int num[maxn];int n, m, x;int qpow(int x, int y) &#123; int ans = 1; while (y) &#123; if (y &amp; 1) ans = ans*x%m; x = x*x%m; y &gt;&gt;= 1; &#125; return ans;&#125;int main() &#123; int T; scanf("%d", &amp;T); while (T--) &#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;x); for (int i=n; i&gt;=0; --i) scanf("%d", num+i); int ans = 0; for (int i=n; i&gt;=0; --i) ans = (ans+num[i]*qpow(x, i)%m)%m; printf("%d\n", ans); &#125; return 0;&#125; Problem B很显然的一道贪心题，从左至右依次判断各位能不能放即可，能放就计数加一并且标记该位已放。代码如下所示： 1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;const int maxn = 25;char str[maxn];int n;bool check(int x) &#123; if (x-1&gt;=0 &amp;&amp; str[x-1]=='2') return false; if (x-2&gt;=0 &amp;&amp; str[x-2]=='2') return false; if (x+1&lt;n &amp;&amp; str[x+1]=='2') return false; if (x+2&lt;n &amp;&amp; str[x+2]=='2') return false; return true;&#125;int main() &#123; int T; scanf("%d", &amp;T); while (T--) &#123; scanf("%d%s", &amp;n, str); int ans = 0; for (int i=0; i&lt;n; ++i) if (str[i]=='0' &amp;&amp; check(i)) &#123; ++ans; str[i] = '2'; &#125; printf("%d\n", ans); &#125; return 0;&#125; Problem C说了两位选手比较，胜利场数之差不能超过1，那么猜想与斐波那契数有关，根据样例以及小数据假想，得出题意是求n最多能到达第几个斐波那契数。代码如下所示： 1234567891011121314151617181920212223#include &lt;cstdio&gt;typedef long long ll;const int maxn = 90;ll num[maxn];ll n;void init() &#123; num[0]=1, num[1]=2; for (int i=2; i&lt;maxn; ++i) num[i] = num[i-1]+num[i-2];&#125;int main() &#123; init(); while (~scanf("%I64d", &amp;n)) &#123; for (int i=0; i&lt;maxn; ++i) if (n &lt;= num[i]) &#123; printf("%d\n", n&lt;num[i] ? i-1 : i); break; &#125; &#125; return 0;&#125; 理论推理如下图所示： Problem D数据规模较小，直接暴力做就可以了，每次找一个符合要求的，并且淘汰掉已走的就可以了。代码如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;const int maxn = 10;struct person &#123; char str[maxn]; int s, t, d, ok, l;&#125; p[maxn&lt;&lt;5];char op[maxn];int main() &#123; int cnt=0, x, y; while (~scanf("%s%s%d%d", p[cnt].str, op, &amp;p[cnt].t, &amp;p[cnt].d)) &#123; sscanf(op, "%d:%d", &amp;x, &amp;y); p[cnt].s = x*60+y; p[cnt].d += p[cnt].s; p[cnt].ok = -1; ++cnt; &#125; x = p[0].s+p[0].t; p[0].ok=1, p[0].l=0; for (int j=1; j&lt;cnt; ++j) &#123; y = 0; bool flag = true; for (int i=1; i&lt;cnt; ++i) if (p[i].ok &lt; 0) &#123; if (p[i].d &lt; x) &#123; p[i].ok = 0; p[i].l = p[i].d-p[i].s; flag = false; break; &#125; if (p[i].s&lt;=x &amp;&amp; (y==0 || p[i].str[0]&gt;p[y].str[0])) y = i; else if (y==0 &amp;&amp; p[i].s&gt;x) &#123; x = p[i].s; y = i; &#125; &#125; if (flag &amp;&amp; y) &#123; p[y].ok = 1; p[y].l = x-p[y].s; x += p[y].t; &#125; &#125; for (int i=0; i&lt;cnt; ++i) printf("%s %d %s\n", p[i].str, p[i].l, p[i].ok ? "Yes" : "No"); return 0;&#125; Problem E算是一道二叉搜索树的模板题吧！对于第一个序列建立一棵二叉搜索树，然后对于每一个给定的序列，去建立好的树中标记搜索即可。代码如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;cstdio&gt;const int maxn = 105;struct node &#123; int val, l, r; bool ok;&#125; p[maxn];int n, m, cnt;int new_node() &#123; p[cnt].l = p[cnt].r = -1; return cnt++;&#125;int build(int id, int val) &#123; if (id == -1) &#123; id = new_node(); p[id].val = val; return id; &#125; if (val &lt; p[id].val) p[id].l = build(p[id].l, val); else p[id].r = build(p[id].r, val); return id;&#125;bool check(int id, int val) &#123; if (id == -1) return false; if (p[id].ok) &#123; if (val &lt; p[id].val) return check(p[id].l, val); return check(p[id].r, val); &#125; if (val == p[id].val) &#123; p[id].ok = true; return true; &#125; return false;&#125;void reset(int id) &#123; if (id == -1) return; if (p[id].l != -1) reset(p[id].l); if (p[id].r != -1) reset(p[id].r); p[id].ok = false;&#125;int main() &#123; int T; scanf("%d", &amp;T); while (T--) &#123; scanf("%d%d", &amp;n, &amp;m); int id = -1; cnt = 0; int num; for (int i=0; i&lt;n; ++i) &#123; scanf("%d", &amp;num); id = build(id, num); &#125; for (int i=1; i&lt;=m; ++i) &#123; bool ok = true; reset(id); for (int j=0; j&lt;n; ++j) &#123; scanf("%d", &amp;num); if (ok &amp;&amp; !check(id, num)) ok = false; &#125; printf("%d: %s\n", i, ok ? "Yes" : "No"); &#125; puts(""); &#125; return 0;&#125; Problem F动态规划题。状态转移方程如下图所示： 代码如下所示： 123456789101112131415161718192021222324#include &lt;cstdio&gt;#include &lt;cstring&gt;const int maxn = 5005;const int mod = 1000000007;int dp[maxn][3];char str[maxn];int main() &#123; while (~scanf("%s", str+1)) &#123; dp[0][0] = dp[0][1] = dp[0][2] = 0; int len = strlen(str+1); for (int i=1; i&lt;=len; ++i) &#123; int k = (str[i]-'0')%3; for (int j=0; j&lt;3; ++j) &#123; int t = (j-k+3)%3; dp[i][j] = (dp[i-1][j]+dp[i-1][t])%mod; if (str[i]!='0' &amp;&amp; k==j) dp[i][j] = (dp[i][j]+1)%mod; &#125; &#125; printf("%d\n", dp[len][0]); &#125; return 0;&#125; 总结题目总体来说，及格比较容易，但是想AK也不是那么容易，区分度较好。]]></content>
      <categories>
        <category>XTU程序设计实践</category>
      </categories>
      <tags>
        <tag>XTU</tag>
        <tag>题解</tag>
        <tag>程序设计实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017年下学期《C语言程序设计》课堂测验-1题解]]></title>
    <url>%2F2017%2F12%2F14%2FXTU%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E8%B7%B5%2F2017%E5%B9%B4%E4%B8%8B%E5%AD%A6%E6%9C%9F%E3%80%8AC%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E8%AF%BE%E5%A0%82%E6%B5%8B%E9%AA%8C-1%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[前面的话本文使用的编辑器是 Sublime Text 3，Build 3143，编译器是 GCC 5.2.1。文章为湘潭大学程序设计实践网站一些考试编程题目的个人题解，不保证是最优解法，仅供参考学习。 当时正闲得无聊，恰好又碰上了这个测验，索性就做了做，网址如下所示：2017年下学期《C语言程序设计》课堂测验-1。如果不能看到题目，可以直接搜索题号1276~1283。 Problem A很简单的签到题，比较一下大小就可以了。代码如下所示： 12345678910111213141516171819202122#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int n, m;int main() &#123; int T; scanf("%d", &amp;T); while (T--) &#123; scanf("%d%d", &amp;n, &amp;m); int ans = n-m; if (ans == 0) puts("None"); else &#123; printf("%s %d", ans&lt;0 ? "Alice" : "Bob", abs(ans)/2); if (ans%2) printf(".5"); puts(""); &#125; &#125; return 0;&#125; Problem B这种找规律的图形题，比较烦，所以是最后做的。做法是，分为两部分输出，先输出上半部分，再输出下半部分。然后判断每行输出多少个空格以及几个字母就OK了，比较简单。代码如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;char op[5];void solve(int x) &#123; int cnt=(x&lt;&lt;1)-1, t=0; for (int i=x; i&gt;0; --i) &#123; for (int j=0; j&lt;cnt; ++j) putchar(' '); --cnt; char ch = 'A'-1; for (int j=0; j&lt;=t; ++j) putchar(++ch); for (; ch&gt;'A';) putchar(--ch); putchar('\n'); ++t; &#125; int ct = (x&lt;&lt;1)-1; t = 0; for (int i=x; i&gt;0; --i) &#123; for (int j=0; j&lt;cnt; ++j) putchar(' '); char ch = 'A'-1; for (int j=0; j&lt;=t; ++j) putchar(++ch); for (; ch&gt;'A';) putchar(--ch); for (int j=0; j&lt;ct; ++j) putchar(' '); ch = 'A'-1; for (int j=0; j&lt;=t; ++j) putchar(++ch); for (; ch&gt;'A';) putchar(--ch); putchar('\n'); ct -= 2; --cnt; ++t; &#125;&#125;int main() &#123; while (~scanf("%s", op)) solve(op[0]-'A'+1); return 0;&#125; Problem C找一个相邻差，然后再将它与所有相邻差比较，有一个不相等就说明不是等差数列。代码如下所示： 123456789101112131415161718192021#include &lt;cstdio&gt;const int maxn = 10005;int num[maxn];int n;int main() &#123; int T; scanf("%d", &amp;T); while (T--) &#123; scanf("%d", &amp;n); for (int i=0; i&lt;n; ++i) scanf("%d", num+i); int ans = num[1]-num[0]; bool ok = true; for (int i=2; i&lt;n&amp;&amp;ok; ++i) if (ans != num[i]-num[i-1]) ok = false; puts(ok ? "Yes" : "No"); &#125; return 0;&#125; Problem D先将所有范围内的素数筛出来，然后利用这些素数判断一个数是不是双素数，接着利用这个判断预处理前缀和，最终对于每次访问可直接得到答案。代码如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;const int maxn = 1000005;const int maxm = 1005;bool vis[maxn];int prime[maxn];int ans[maxn];int a, b, cnt;void filter() &#123; vis[0] = vis[1] = true; for (int i=2; i&lt;maxm; ++i) if (!vis[i]) for (int j=i*i; j&lt;maxn; j+=i) vis[j] = true; for (int i=2; i&lt;maxn; ++i) if (!vis[i]) prime[cnt++] = i;&#125;bool is_double_prime(int x) &#123; for (int i=0; i&lt;cnt&amp;&amp;prime[i]*prime[i]&lt;=x; ++i) if (x%prime[i]==0 &amp;&amp; prime[i]*prime[i]!=x &amp;&amp; !vis[x/prime[i]]) return true; return false;&#125;void init() &#123; filter(); for (int i=6; i&lt;maxn; ++i) ans[i] = ans[i-1]+is_double_prime(i);&#125;int main() &#123; init(); int T; scanf("%d", &amp;T); while (T--) &#123; scanf("%d%d", &amp;a, &amp;b); printf("%d\n", ans[b]-ans[a-1]); &#125; return 0;&#125; Problem E类似于将26进制数转换为10进制数，只不过最高位永远为1，边转换边模，防止溢出。为什么可以这么转换呢？有点类似于秦九韶算法，最先出现的数位权越大，经过后面的迭代，最先出现的权就是最大的。代码如下所示： 1234567891011121314#include &lt;cstdio&gt;const int maxn = 1005;const int p = 1000000007;char str[maxn];int main() &#123; while (~scanf("%s", str)) &#123; int ans = 1; for (int i=0; str[i]; ++i) ans = ((long long)ans*26+str[i]-'a')%p; printf("%d\n", ans); &#125; return 0;&#125; Problem F记录字母种类可以用一个数的二进制位来标记，某一位为1就表示该字母出现过，最后数这个数二进制位为1的有几位就行了；那单词个数如何记录呢？其实也很简单，只要在某一个不是字母的字符前面出现字母，那么必是一个单词，当然，这个只能用一次，记得清除标记。代码如下所示： 12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;const int maxn = 205;char str[maxn];int one(int x) &#123; int ans = 0; while (x) &#123; if (x &amp; 1) ++ans; x &gt;&gt;= 1; &#125; return ans;&#125;int main() &#123; while (fgets(str, maxn, stdin)) &#123; int ans=0, cnt=0; bool ok = false; for (int i=0; str[i]; ++i) &#123; if ((str[i]&gt;='A'&amp;&amp;str[i]&lt;='Z') || (str[i]&gt;='a'&amp;&amp;str[i]&lt;='z')) &#123; ans |= (1&lt;&lt;((str[i]&gt;='A'&amp;&amp;str[i]&lt;='Z' ? str[i]-'A' : str[i]-'a'))); ok = true; &#125; else &#123; if (ok) ++cnt; ok = false; &#125; &#125; puts(one(ans)&gt;10||cnt&gt;10 ? "No" : "Yes"); &#125; return 0;&#125; Problem G一开始，看到a与b只相差10，果断直接通分，用64位整数存储，最后化简，然后就WA了。最后看到了b最大有100，所以超过了范围。然后灵机一动，一次不行，那就两次吧，哈哈，AC了。代码如下所示： 123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;typedef long long ll;int a, b;ll gcd(ll a, ll b) &#123; return b ? gcd(b, a%b) : a;&#125;int main() &#123; int T; scanf("%d", &amp;T); while (T--) &#123; scanf("%d%d", &amp;a, &amp;b); ll s1=1, t1=0, t=(a+b)&gt;&gt;1; for (int i=a; i&lt;t; ++i) s1 *= i; for (int i=a; i&lt;t; ++i) t1 += s1/i; ll d = gcd(s1, t1); s1 /= d; t1 /= d; ll s2=1, t2=0; for (int i=t; i&lt;=b; ++i) s2 *= i; for (int i=t; i&lt;=b; ++i) t2 += s2/i; d = gcd(s2, t2); s2 /= d; t2 /= d; d = s1/gcd(s1, s2)*s2; t = d/s1*t1+d/s2*t2; ll s = gcd(d, t); printf("%I64d/%I64d\n", t/s, d/s); &#125; return 0;&#125; Problem H这题也比较容易想到，显然最高位为1，那么低位的1的个数显然不能低于位数的一半，这就将问题转换为在低位中选择特定个数1的位置的种类有多少种，显然需要用到杨辉三角，于是预处理杨辉三角。对于位数n，就有在n-1位中，选择一半以上1的种类的个数。（PS：一开始，以为是要求1-n的所有，所以WA了一发）代码如下所示： 1234567891011121314151617181920212223242526#include &lt;cstdio&gt;typedef long long ll;const int maxn = 65;ll tri[maxn][maxn];ll ans[maxn];int n;void init() &#123; for (int i=0; i&lt;maxn; ++i) &#123; tri[i][0] = tri[i][i] = 1; for (int j=1; j&lt;i; ++j) tri[i][j] = tri[i-1][j-1]+tri[i-1][j]; &#125; for (int i=1; i&lt;maxn; ++i) &#123; int t = i-1; for (int j=t/2+t%2; j&lt;i; ++j) ans[i] += tri[t][j]; &#125;&#125;int main() &#123; init(); while (~scanf("%d", &amp;n)) printf("%I64d\n", ans[n]); return 0;&#125; 总结：总体来说，题目还是比较简单的，但是还是要花一点时间来思考。]]></content>
      <categories>
        <category>XTU程序设计实践</category>
      </categories>
      <tags>
        <tag>XTU</tag>
        <tag>C语言程序设计</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抽象工厂模式]]></title>
    <url>%2F2017%2F10%2F07%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2F%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前面的话本文使用的 IDE 是 Eclipse Mars.2 Release (4.5.2)。文章为学习设计模式（来源：菜鸟教程）时所记录的内容，可能包含遇到的问题，仅供学习交流。 抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。 介绍意图：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 主要解决：主要解决接口选择的问题。 何时使用：系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。 如何解决：在一个产品族里面，定义多个产品。 关键代码：在一个工厂里聚合多个同类产品。 应用实例：工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品。假设一种情况（现实中是不存在的，要不然，没法进入共产主义了，但有利于说明抽象工厂模式），在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用 OO 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。 优点：当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。 缺点：产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。 注意事项：产品族难扩展，产品等级易扩展。 实现演示实例的关系图如下所示： 步骤1为形状创建一个接口。代码如下所示：123public interface Shape &#123; void draw();&#125; 步骤2创建实现接口的实体类。代码如下所示：12345678public class Rectangle implements Shape &#123; @Override public void draw() &#123; System.out.println("Inside Rectangle::draw() method."); &#125;&#125; 12345678public class Circle implements Shape &#123; @Override public void draw() &#123; System.out.println("Inside Circle::draw() method."); &#125;&#125; 12345678public class Square implements Shape &#123; @Override public void draw() &#123; System.out.println("Inside Square::draw() method."); &#125;&#125; 步骤3为颜色创建一个接口。代码如下所示：123public interface Color &#123; void fill();&#125; 步骤4创建实现接口的实体类。代码如下所示：12345678public class Red implements Color &#123; @Override public void fill() &#123; System.out.println("Inside Red::fill() method."); &#125;&#125; 12345678public class Green implements Color &#123; @Override public void fill() &#123; System.out.println("Inside Green::fill() method."); &#125;&#125; 12345678public class Blue implements Color &#123; @Override public void fill() &#123; System.out.println("Inside Blue::fill() method."); &#125;&#125; 步骤5为 Color 和 Shape 对象创建抽象类来获取工厂。代码如下所示：1234public abstract class AbstractFactory &#123; abstract Color getColor(String color); abstract Shape getShape(String shape);&#125; 步骤6创建扩展了 AbstractFactory 的工厂类，基于给定的信息生成实体类的对象。代码如下所示：1234567891011121314151617181920212223public class ShapeFactory extends AbstractFactory &#123; @Override Color getColor(String color) &#123; return null; &#125; @Override public Shape getShape(String shapeType) &#123; if (shapeType == null) &#123; return null; &#125; if (shapeType.equalsIgnoreCase("CIRCLE")) &#123; return new Circle(); &#125; else if (shapeType.equalsIgnoreCase("RECTANGLE")) &#123; return new Rectangle(); &#125; else if (shapeType.equalsIgnoreCase("SQUARE")) &#123; return new Square(); &#125; return null; &#125;&#125; 1234567891011121314151617181920212223public class ColorFactory extends AbstractFactory &#123; @Override public Color getColor(String colorType) &#123; if (colorType == null) &#123; return null; &#125; if (colorType.equalsIgnoreCase("RED")) &#123; return new Red(); &#125; else if (colorType.equalsIgnoreCase("GREEN")) &#123; return new Green(); &#125; else if (colorType.equalsIgnoreCase("BLUE")) &#123; return new Blue(); &#125; return null; &#125; @Override Shape getShape(String shape) &#123; return null; &#125;&#125; 步骤7创建一个工厂创造器/生成器类，通过传递形状或颜色信息来获取工厂。代码如下所示：123456789101112public class FactoryProducer &#123; public static AbstractFactory getFactory(String choice) &#123; if (choice.equalsIgnoreCase("SHAPE")) &#123; return new ShapeFactory(); &#125; else if (choice.equalsIgnoreCase("COLOR")) &#123; return new ColorFactory(); &#125; return null; &#125;&#125; 步骤8使用 FactoryProducer 来获取 AbstractFactory，通过传递类型信息来获取实体类的对象。代码如下所示：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class AbstractFactoryPatternDemo &#123; public static void main(String[] args) &#123; // 获取形状工厂 AbstractFactory shapeFactory = FactoryProducer.getFactory("SHAPE"); // 获取形状为 Circle 的对象 Shape shape1 = shapeFactory.getShape("CIRCLE"); // 调用 Circle 的 draw 方法 shape1.draw(); // 获取形状为 Rectangle 的对象 Shape shape2 = shapeFactory.getShape("RECTANGLE"); // 调用 Rectangle 的 draw 方法 shape2.draw(); // 获取形状为 Square 的对象 Shape shape3 = shapeFactory.getShape("SQUARE"); // 调用 Square 的 draw 方法 shape3.draw(); // 获取颜色工厂 AbstractFactory colorFactory = FactoryProducer.getFactory("COLOR"); // 获取颜色为 Red 的对象 Color color1 = colorFactory.getColor("RED"); // 调用 Red 的 fill 方法 color1.fill(); // 获取颜色为 Green 的对象 Color color2 = colorFactory.getColor("Green"); // 调用 Green 的 fill 方法 color2.fill(); // 获取颜色为 Blue 的对象 Color color3 = colorFactory.getColor("BLUE"); // 调用 Blue 的 fill 方法 color3.fill(); &#125;&#125; 步骤9验证输出。如下所示： Inside Circle::draw() method.Inside Rectangle::draw() method.Inside Square::draw() method.Inside Red::fill() method.Inside Green::fill() method.Inside Blue::fill() method.]]></content>
      <categories>
        <category>设计模式学习记录</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>抽象工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工厂模式]]></title>
    <url>%2F2017%2F10%2F04%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2F%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前面的话本文使用的 IDE 是 Eclipse Mars.2 Release (4.5.2)。文章为学习设计模式（来源：菜鸟教程）时所记录的内容，可能包含遇到的问题，仅供学习交流。 工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。 介绍意图：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。 主要解决：主要解决接口选择的问题。 何时使用：我们明确地计划不同条件下创建不同实例时。 如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。 关键代码：创建过程在其子类执行。 应用实例：1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。 优点：1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。 缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。 注意事项：作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。 实现演示实例的关系图如下所示： 步骤1创建一个接口。代码如下所示：123public interface Shape &#123; void draw();&#125; 步骤2创建实现接口的实体类。代码如下所示：12345678public class Rectangle implements Shape &#123; @Override public void draw() &#123; System.out.println("Inside Rectangle::draw() method."); &#125;&#125; 12345678public class Circle implements Shape &#123; @Override public void draw() &#123; System.out.println("Inside Circle::draw() method."); &#125;&#125; 12345678public class Square implements Shape &#123; @Override public void draw() &#123; System.out.println("Inside Square::draw() method."); &#125;&#125; 步骤3创建一个工厂，生成基于给定信息的实体类的对象。代码如下所示：12345678910111213141516171819202122public class ShapeFactory &#123; /** * 获取形状类型的对象 * @param shapeType * @return */ public Shape getShape(String shapeType) &#123; if (shapeType == null) &#123; return null; &#125; if (shapeType.equalsIgnoreCase("CIRCLE")) &#123; return new Circle(); &#125; else if (shapeType.equalsIgnoreCase("RECTANGLE")) &#123; return new Rectangle(); &#125; else if (shapeType.equalsIgnoreCase("SQUARE")) &#123; return new Square(); &#125; return null; &#125;&#125; 步骤4使用该工厂，通过传递类型信息来获取实体类的对象。代码如下所示：12345678910111213141516171819202122232425public class FactoryPatternDemo &#123; public static void main(String[] args) &#123; ShapeFactory shapeFactory = new ShapeFactory(); // 获取 Circle 的对象，并调用它的 draw 方法 Shape shape1 = shapeFactory.getShape("CIRCLE"); // 调用 Circle 的 draw 方法 shape1.draw(); // 获取 Rectangle 的对象，并调用它的 draw 方法 Shape shape2 = shapeFactory.getShape("RECTANGLE"); // 调用 Rectangle 的 draw 方法 shape2.draw(); // 获取 Square 的对象，并调用它的 draw 方法 Shape shape3 = shapeFactory.getShape("SQUARE"); // 调用 Square 的 draw 方法 shape3.draw(); &#125;&#125; 步骤5验证输出。如下所示： Inside Circle::draw() method.Inside Rectangle::draw() method.Inside Square::draw() method.]]></content>
      <categories>
        <category>设计模式学习记录</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式简介]]></title>
    <url>%2F2017%2F10%2F04%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[前面的话本文使用的 IDE 是 Eclipse Mars.2 Release (4.5.2)。文章为学习设计模式（来源：菜鸟教程）时所记录的内容，可能包含遇到的问题，仅供学习交流。 设计模式简介设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。 设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。 设计模式的类型根据设计模式的参考书 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 中所提到的，总共有 23 种设计模式。这些模式可以分为三大类： 创建型模式（Creational Patterns）结构型模式（Structural Patterns）行为型模式（Behavioral Patterns） 当然，还会讨论另一类设计模式： J2EE 设计模式。 创建型模式这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。 其中有5种，包括： 工厂模式（Factory Pattern）抽象工厂模式（Abstract Factory Pattern）单例模式（Singleton Pattern）建造者模式（Builder Pattern）原型模式（Prototype Pattern） 结构型模式这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。 其中有8种，包括： 适配器模式（Adapter Pattern）桥接模式（Bridge Pattern）过滤器模式（Filter Criteria Pattern）组合模式（Composite Pattern）装饰器模式（Decorator Pattern）外观模式（Facade Pattern）享元模式（Flyweight Pattern）代理模式（Proxy Pattern） 行为型模式这些设计模式特别关注对象之间的通信。 其中有12种，包括： 责任链模式（Chain of Responsibility Pattern）命令模式（Command Pattern）解释器模式（Interpreter Pattern）迭代器模式（Iterator Pattern）中介者模式（Mediator Pattern）备忘录模式（Memento Pattern）观察者模式（Observer Pattern）状态模式（State Pattern）空对象模式（Null Object Pattern）策略模式（Strategy Pattern）模板模式（Template Pattern）访问者模式（Visitor Pattern） J2EE 模式这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。 其中有8种，包括： MVC 模式（MVC Pattern）业务代表模式（Business Delegate Pattern）组合实体模式（Composite Entity Pattern）数据访问对象模式（Data Access Object Pattern）前端控制器模式（Front Controller Pattern）拦截过滤器模式（Intercepting Filter Pattern）服务定位器模式（Service Locator Pattern）传输对象模式（Transfer Object Pattern） 下面用一个图片来整体描述一下设计模式之间的关系： 设计模式的六大原则1、开闭原则（Open Close Principle）开闭原则的意思是：对扩展开放，对修改关闭。简而言之，就是实现热插拔，提高扩展性。 2、里氏代换原则（Liskov Substitution Principle）里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。里氏代换原则是对开闭原则的补充。简而言之，就是实现抽象的规范，实现子父类互相替换。 3、依赖倒转原则（Dependence Inversion Principle）这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。简而言之，就是针对接口编程，实现开闭原则的基础。 4、接口隔离原则（Interface Segregation Principle）这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。简而言之，就是降低耦合度，接口单独设计，互相隔离。 5、迪米特法则，又称最少知道原则（Demeter Principle）最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。简而言之，就是功能模块尽量独立。 6、合成复用原则（Composite Reuse Principle）合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。简而言之，就是尽量使用聚合、组合，而不是继承。]]></content>
      <categories>
        <category>设计模式学习记录</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RecyclerView的简单用法]]></title>
    <url>%2F2017%2F08%2F23%2FAndroid%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2FRecyclerView%E7%9A%84%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前面的话本文使用的 IDE 是 Android Studio 2.3.1 ，模拟器是夜神模拟器 5.0.0.0 。文章为学习《第一行代码——Android》（第二版）时所记录的内容，可能包含遇到的问题，仅供学习交流。 准备工作首先，在Android Studio上新建一个项目，项目名叫RecyclerViewTest，并让Android Studio自动帮我们创建好活动。 RecyclerView的基本用法添加依赖库RecyclerView属于新增的控件，所以首先需要在项目的build.gradle中添加相应的依赖库。打开app/build.gradle文件，在dependencies闭包中添加如下内容：12345678910dependencies &#123; compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;]) androidTestCompile(&apos;com.android.support.test.espresso:espresso-core:2.2.2&apos;, &#123; exclude group: &apos;com.android.support&apos;, module: &apos;support-annotations&apos; &#125;) compile &apos;com.android.support:appcompat-v7:25.3.1&apos; compile &apos;com.android.support:recyclerview-v7:25.3.1&apos; compile &apos;com.android.support.constraint:constraint-layout:1.0.2&apos; testCompile &apos;junit:junit:4.12&apos;&#125; 添加的代码如下（后面的数字与上面的一项相同即可）：1compile &apos;com.android.support:recyclerview-v7:25.3.1&apos; 添加完成之后，记得要点击一下右上角的Sync Now来进行同步。 修改布局和活动文件修改activity_main.xml中的代码，如下所示：123456789&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;android.support.v7.widget.RecyclerView android:id="@+id/recycler_view" android:layout_width="match_parent" android:layout_height="match_parent"&gt;&lt;/android.support.v7.widget.RecyclerView&gt;&lt;/LinearLayout&gt; 需要注意的是，由于RecyclerView并不是内置在系统SDK当中的，所以需要把完整的包路径写出来。因为我们想要使用RecyclerView来实现和上一节中的ListView相同的效果，因此就需要准备一份同样的水果图片。这里我们直接从上一个项目中复制drawable-hdpi到本项目中即可，另外把Fruit类和fruit_item.xml也复制过来，省得将同样的代码再写一遍。其中，Fruit类用于存储水果数据，内容如下所示：123456789101112131415161718public class Fruit &#123; private String name; private int imageId; public Fruit(String name, int imageId) &#123; this.name = name; this.imageId = imageId; &#125; public String getName() &#123; return name; &#125; public int getImageId() &#123; return imageId; &#125;&#125; fruit_item.xml用于子项自定义布局，内容如下所示：123456789101112131415161718&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;ImageView android:id="@+id/fruit_image" android:layout_width="wrap_content" android:layout_height="wrap_content"/&gt; &lt;TextView android:id="@+id/fruit_name" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_vertical" android:layout_marginLeft="10dp"/&gt;&lt;/LinearLayout&gt; 紧接着我们需要为RecyclerView准备一个适配器，新建FruitAdapter类，代码如下所示：12345678910111213141516171819202122232425262728293031323334353637public class FruitAdapter extends RecyclerView.Adapter&lt;FruitAdapter.ViewHolder&gt; &#123; private List&lt;Fruit&gt; mFruitList; public FruitAdapter(List&lt;Fruit&gt; fruitList) &#123; mFruitList = fruitList; &#125; @Override public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.fruit_item, parent, false); ViewHolder holder = new ViewHolder(view); return holder; &#125; @Override public void onBindViewHolder(ViewHolder holder, int position) &#123; Fruit fruit = mFruitList.get(position); holder.fruitImage.setImageResource(fruit.getImageId()); holder.fruitName.setText(fruit.getName()); &#125; @Override public int getItemCount() &#123; return mFruitList.size(); &#125; static class ViewHolder extends RecyclerView.ViewHolder &#123; ImageView fruitImage; TextView fruitName; public ViewHolder(View itemView) &#123; super(itemView); fruitImage = (ImageView) itemView.findViewById(R.id.fruit_image); fruitName = (TextView) itemView.findViewById(R.id.fruit_name); &#125; &#125;&#125; 这里首先定义了一个内部类ViewHolder，ViewHolder要继承自RecyclerView.ViewHolder。然后ViewHolder的构造方法中要传入一个View参数，这个参数通常就是RecyclerView子项的最外层布局，那么我们就可以通过findViewById()方法来获取到布局中的ImageView和TextView的实例了。接下来，FruitAdapter中也有一个构造方法，这个方法用于把要展示的数据源传进来，并赋值给一个全局变量mFruitList，我们后续的操作都将在这个数据源的基础上进行。由于FruitAdapter是继承自RecyclerView.Adapter的，那么就必须重写onCreateViewHolder()、onBindViewHolder()和getItemCount()这3个方法。onCreateViewHolder()方法是用于创建ViewHolder实例的，在这个方法中将fruit_item布局加载进来，然后创建一个ViewHolder实例，并把加载出来的布局传入到构造方法中，最后将ViewHolder的实例返回。onBindViewHolder()方法是用于对RecyclerView子项的数据进行赋值的，会在每个子项被滚动到屏幕内的时候执行，这里我们通过position参数得到当前项的Fruit实例，然后再将数据设置到ViewHolder的ImageView和TextView当中即可。getItemCount()方法就非常简单了，它用于告诉RecyclerView一共有多少子项，直接返回数据源的长度就可以了。适配器准备好了之后，我们就可以开始使用RecyclerView了，修改MainActivity中的代码，如下所示：12345678910111213141516171819202122232425262728293031323334353637383940public class MainActivity extends AppCompatActivity &#123; private List&lt;Fruit&gt; fruitList = new ArrayList&lt;&gt;(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initFruits(); // 初始化水果数据 RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recycler_view); LinearLayoutManager layoutManager = new LinearLayoutManager(this); recyclerView.setLayoutManager(layoutManager); FruitAdapter adapter = new FruitAdapter(fruitList); recyclerView.setAdapter(adapter); &#125; private void initFruits() &#123; for (int i=0; i&lt;2; ++i) &#123; Fruit apple = new Fruit("Apple", R.drawable.apple_pic); fruitList.add(apple); Fruit banana = new Fruit("Banana", R.drawable.banana_pic); fruitList.add(banana); Fruit orange = new Fruit("Orange", R.drawable.orange_pic); fruitList.add(orange); Fruit watermelon = new Fruit("Watermelon", R.drawable.watermelon_pic); fruitList.add(watermelon); Fruit pear = new Fruit("Pear", R.drawable.pear_pic); fruitList.add(pear); Fruit grape = new Fruit("Grape", R.drawable.grape_pic); fruitList.add(grape); Fruit pineapple = new Fruit("Pineapple", R.drawable.pineapple_pic); fruitList.add(pineapple); Fruit strawberry = new Fruit("Strawberry", R.drawable.strawberry_pic); fruitList.add(strawberry); Fruit cherry = new Fruit("Cherry", R.drawable.cherry_pic); fruitList.add(cherry); Fruit mango = new Fruit("Mango", R.drawable.mango_pic); fruitList.add(mango); &#125; &#125;&#125; 这里，首先使用了一个和ListViewTest项目同样的initFruits()方法，用于初始化所有的水果数据。接着在onCreate()方法中先获取到RecyclerView的实例，然后创建一个LinearLayoutManager对象，并将它设置到RecyclerView当中。LayoutManager用于指定RecyclerView的布局方式，这里使用的LinearLayoutManager是线性布局的意思，可以实现和ListView类似的效果。接下来我们创建了FruitAdapter的实例，并将水果数据传入到FruitAdapter的构造方法中，最后调用RecyclerView的setAdapter()方法来完成适配器设置，这样RecyclerView和数据之间的关联就建立完成了。运行程序，效果如下所示：可以看到，我们使用RecyclerView实现了和ListView几乎一模一样的效果，虽说代码量并没有明显地减少，但是逻辑变得更加清晰了。当然这只是RecyclerView的基本用法而已，接下来我们就要看看RecyclerView还能实现哪些ListView实现不了的效果。 实现横向滚动我们知道，ListView的扩展性并不好，它只能实现纵向滚动的效果，如果想进行横向滚动的话，ListView就做不到了。这样的话，我们就需要借助于RecyclerView了。首先要对fruit_item布局进行修改，因为目前这个布局里面的元素是水平排列的，适用于纵向滚动的场景，而如果我们要实现横向滚动的话，应该把fruit_item里的元素改成垂直排列才比较合理。修改fruit_item.xml中的代码，如下所示：1234567891011121314151617181920&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="100dp" android:layout_height="wrap_content"&gt; &lt;ImageView android:id="@+id/fruit_image" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_horizontal"/&gt; &lt;TextView android:id="@+id/fruit_name" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_horizontal" android:layout_marginTop="10dp"/&gt;&lt;/LinearLayout&gt; 这里，我们将LinearLayout改成垂直方向排列，并把宽度设为100dp。这里将宽度指定为固定值是因为每种水果的文字长度不一致，如果用wrap_content的话，RecyclerView的子项就会有长有短，非常不美观；而如果用match_parent的话，就会导致宽度过长，一个子项占满整个屏幕。最后，我们将ImageView和TextView都设置成了在布局中水平居中，并且使用layout_marginTop属性让文字和图片之间保持一些距离。接下来，在MainActivity中添加代码如下：123LinearLayoutManager layoutManager = new LinearLayoutManager(this);layoutManager.setOrientation(LinearLayoutManager.HORIZONTAL); // 添加的内容recyclerView.setLayoutManager(layoutManager); 注意：MainActivity中只加入了一行代码，调用LinearLayoutManager的setOrientation()方法来设置布局的排列方向，默认是纵向排列的，我们传入LinearLayoutManager.HORIZONTAL表示让布局横行排列，这样RecyclerView就可以横向滚动了。 运行程序，效果如下所示：为什么ListView很难或者根本无法实现的效果在RecyclerView上这么轻松就能实现了呢？这主要得益于RecyclerView出色的设计。ListView的布局排列是由自身去管理的，而RecyclerView则将这个工作交给了LayoutManager，LayoutManager中制定了一套可扩展的布局排列接口，子类只要按照接口的规范来实现，就能定制出各种不同排列方式的布局了。 实现瀑布流布局首先还是来修改一下fruit_item.xml中的代码，如下所示：123456789101112131415161718192021&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_margin="5dp"&gt; &lt;ImageView android:id="@+id/fruit_image" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_horizontal"/&gt; &lt;TextView android:id="@+id/fruit_name" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="left" android:layout_marginTop="10dp"/&gt;&lt;/LinearLayout&gt; 首先将LinearLayout的宽度由100dp改成了match_parent，因为瀑布流布局的宽度应该是根据布局的列数来自动适配的，而不是一个固定值。另外我们使用了layout_margin属性来让子项之间互留一点间距，这样就不至于所有子项都紧贴在一起。还有就是将TextView的对齐属性改成了居左对齐，因为待会儿我们会将文字的长度变长，如果还是居中显示，会感觉怪怪的。修改MainActivity中的代码，如下所示：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class MainActivity extends AppCompatActivity &#123; private List&lt;Fruit&gt; fruitList = new ArrayList&lt;&gt;(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initFruits(); // 初始化水果数据 RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recycler_view); StaggeredGridLayoutManager layoutManager = new StaggeredGridLayoutManager(3, StaggeredGridLayoutManager.VERTICAL); recyclerView.setLayoutManager(layoutManager); FruitAdapter adapter = new FruitAdapter(fruitList); recyclerView.setAdapter(adapter); &#125; private void initFruits() &#123; for (int i=0; i&lt;2; ++i) &#123; Fruit apple = new Fruit(getRandomLengthName("Apple"), R.drawable.apple_pic); fruitList.add(apple); Fruit banana = new Fruit(getRandomLengthName("Banana"), R.drawable.banana_pic); fruitList.add(banana); Fruit orange = new Fruit(getRandomLengthName("Orange"), R.drawable.orange_pic); fruitList.add(orange); Fruit watermelon = new Fruit(getRandomLengthName("Watermelon"), R.drawable.watermelon_pic); fruitList.add(watermelon); Fruit pear = new Fruit(getRandomLengthName("Pear"), R.drawable.pear_pic); fruitList.add(pear); Fruit grape = new Fruit(getRandomLengthName("Grape"), R.drawable.grape_pic); fruitList.add(grape); Fruit pineapple = new Fruit(getRandomLengthName("Pineapple"), R.drawable.pineapple_pic); fruitList.add(pineapple); Fruit strawberry = new Fruit(getRandomLengthName("Strawberry"), R.drawable.strawberry_pic); fruitList.add(strawberry); Fruit cherry = new Fruit(getRandomLengthName("Cherry"), R.drawable.cherry_pic); fruitList.add(cherry); Fruit mango = new Fruit(getRandomLengthName("Mango"), R.drawable.mango_pic); fruitList.add(mango); &#125; &#125; private String getRandomLengthName(String name) &#123; Random random = new Random(); int length = random.nextInt(20)+1; StringBuilder builder = new StringBuilder(); for (int i = 0; i &lt; length; ++i) &#123; builder.append(name); &#125; return builder.toString(); &#125;&#125; 首先，在onCreate()方法中，我们创建了一个StaggeredGridLayoutManager的实例。StaggeredGridLayoutManager的构造方法接收两个参数，第一个参数用于指定布局的列数，传入 3 表示会把布局分为 3 列；第二个参数用于指定布局的排列方向，传入StaggeredGridLayoutManager.VERTICAL表示会让布局纵向排列，最后再把创建好的实例设置到RecyclerView当中就可以了。没错，仅仅修改了一行代码，我们就已经成功实现瀑布流布局的效果了。不过由于瀑布流布局需要各个子项的高度不一致时才能看出明显的效果，因此设计了一个getRandomLengthName()方法，这个方法使用了Random对象来创造一个 1 到 20 之间的随机数，然后将参数中传入的字符串重复随机遍。在initFruits()方法中，每个水果的名字都改成调用getRandomLengthName()这个方法来生成，这样就能保证各水果名字的长短差距都比较大，子项的高度也就各不相同了。运行程序，效果如下所示： RecyclerView的点击事件不同于ListView的是，RecyclerView并没有提供类似于setOnItemClickListener()这样的注册监听器方法，而是需要我们自己给子项具体的View去注册点击事件，相比于ListView来说，实现起来要复杂一些。那么你可能就有疑问了，为什么RecyclerView在各个方面的设计都要优于ListView，偏偏在点击事件上却没有处理得非常好呢？其实不是这样的，ListView在点击事件上的处理并不人性化，setOnItemClickListener()方法注册的是子项的点击事件，但如果我想点击的是子项里面具体的某一个按钮呢？虽然ListView也是能做到的，但是实现起来就相对比较麻烦了。为此，RecyclerView干脆直接摒弃了子项点击事件的监听器，所有的点击事件都由具体的View去注册，就再没有这个困扰了。下面注册点击事件，修改FruitAdapter中的代码，如下所示：1234567891011121314151617181920212223242526272829303132333435363738394041public class FruitAdapter extends RecyclerView.Adapter&lt;FruitAdapter.ViewHolder&gt; &#123; ...... @Override public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.fruit_item, parent, false); final ViewHolder holder = new ViewHolder(view); holder.fruitView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; int position = holder.getAdapterPosition(); Fruit fruit = mFruitList.get(position); Toast.makeText(v.getContext(), "you clicked view " + fruit.getName(), Toast.LENGTH_SHORT).show(); &#125; &#125;); holder.fruitImage.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; int position = holder.getAdapterPosition(); Fruit fruit = mFruitList.get(position); Toast.makeText(v.getContext(), "you clicked image " + fruit.getName(), Toast.LENGTH_SHORT).show(); &#125; &#125;); return holder; &#125; ...... static class ViewHolder extends RecyclerView.ViewHolder &#123; View fruitView; ImageView fruitImage; TextView fruitName; public ViewHolder(View itemView) &#123; super(itemView); fruitView = itemView; fruitImage = (ImageView) itemView.findViewById(R.id.fruit_image); fruitName = (TextView) itemView.findViewById(R.id.fruit_name); &#125; &#125;&#125; 首先修改了ViewHolder，在ViewHolder中添加了fruitView变量来保存子项最外层布局的实例，然后在onCreateViewHolder()方法中注册点击事件就可以了。这里分别为最外层布局和ImageView都注册了点击事件，RecyclerView的强大之处也在这里，它可以轻松地实现子项中任意控件或布局的点击事件。我们在两个点击事件中先获取了用户点击的position，然后通过position拿到相应的Fruit实例，再使用Toast分别弹出两种不同的内容以示区别。运行程序，点击梨子的图片部分，效果如下所示：然后再点击草莓的文字部分，效果如下所示： 注意：由于TextView并没有注册点击事件，因此点击文字这个事件会被子项的最外层布局捕获到。 注意： 文中所提到的图片可以从作者的源码库中获取，点击这里。]]></content>
      <categories>
        <category>Android学习笔记</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>RecyclerView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F08%2F19%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>test</tag>
      </tags>
  </entry>
</search>
